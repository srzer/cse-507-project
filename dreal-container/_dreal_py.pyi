import typing
from _typeshed import Incomplete
from typing import ClassVar, Iterator, overload

class Bitset:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    @overload
    def __init__(self, arg0: Bitset) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1: int) -> None: ...
    def add(self, arg0: int) -> None: ...
    def clear(self) -> None: ...
    def compose(self, arg0: Bitset) -> Bitset: ...
    def empty(self) -> bool: ...
    def fill(self, arg0: int, arg1: int) -> None: ...
    def max(self) -> int: ...
    def min(self) -> int: ...
    def next(self, arg0: int) -> int: ...
    def remove(self, arg0: int) -> None: ...
    def resize(self, arg0: int) -> None: ...
    def size(self) -> int: ...
    def __getitem__(self, arg0: int) -> bool: ...
    def __iter__(self): ...

class Box:
    def __init__(self, arg0) -> None: ...
    @overload
    def Add(self, arg0) -> None: ...
    @overload
    def Add(self, arg0, arg1: float, arg2: float) -> None: ...
    def InplaceUnion(self, arg0: Box) -> Box: ...
    def MaxDiam(self) -> tuple[float, int]: ...
    @overload
    def bisect(self, arg0: int) -> tuple[Box, Box]: ...
    @overload
    def bisect(self, arg0) -> tuple[Box, Box]: ...
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def has_key(self, arg0) -> bool: ...
    def index(self, arg0) -> int: ...
    def items(self, *args, **kwargs): ...
    def keys(self, *args, **kwargs): ...
    def set(self, arg0: Box) -> Box: ...
    def set_empty(self) -> None: ...
    def size(self) -> int: ...
    def values(self) -> list[Interval]: ...
    def variable(self, *args, **kwargs): ...
    def __delitem__(self, arg0) -> None: ...
    def __eq__(self, arg0: Box) -> bool: ...
    @overload
    def __getitem__(self, arg0) -> Interval: ...
    @overload
    def __getitem__(self, arg0: int) -> Interval: ...
    def __iter__(self) -> typing.Iterator[Interval]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: Box) -> bool: ...
    @overload
    def __setitem__(self, arg0, arg1: Interval) -> None: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Interval) -> None: ...

class Config:
    brancher: Incomplete
    nlopt_ftol_abs: float
    nlopt_ftol_rel: float
    nlopt_maxeval: int
    nlopt_maxtime: float
    number_of_jobs: int
    precision: float
    use_local_optimization: bool
    use_polytope: bool
    use_polytope_in_forall: bool
    use_worklist_fixpoint: bool
    def __init__(self) -> None: ...

class Context:
    version: ClassVar[str] = ...  # read-only
    config: Config
    def __init__(self) -> None: ...
    def Assert(self, arg0: Formula) -> None: ...
    def CheckSat(self) -> Box | None: ...
    @overload
    def DeclareVariable(self, arg0: Variable) -> None: ...
    @overload
    def DeclareVariable(self, arg0: Variable, arg1: Expression, arg2: Expression) -> None: ...
    @staticmethod
    def Exit() -> None: ...
    def Maximize(self, arg0: Expression) -> None: ...
    def Minimize(self, arg0: Expression) -> None: ...
    def Pop(self, arg0: int) -> None: ...
    def Push(self, arg0: int) -> None: ...
    @overload
    def SetInfo(self, arg0: str, arg1: float) -> None: ...
    @overload
    def SetInfo(self, arg0: str, arg1: str) -> None: ...
    def SetInterval(self, arg0: Variable, arg1: float, arg2: float) -> None: ...
    def SetLogic(self, arg0: Logic) -> None: ...
    @overload
    def SetOption(self, arg0: str, arg1: float) -> None: ...
    @overload
    def SetOption(self, arg0: str, arg1: str) -> None: ...
    @property
    def box(self) -> Box: ...

class Contractor:
    def __init__(self, arg0: Config) -> None: ...
    def Prune(self, arg0: ContractorStatus) -> None: ...
    def input(self) -> DynamicBitset: ...

class ContractorStatus:
    def __init__(self, arg0: Box) -> None: ...
    def box(self) -> Box: ...
    def explanation(self) -> Set[Formula]: ...
    def mutable_box(self) -> Box: ...
    def mutable_output(self) -> DynamicBitset: ...
    def output(self) -> DynamicBitset: ...

class DynamicBitset:
    def __init__(self, arg0: int) -> None: ...
    def all(self) -> bool: ...
    def any(self) -> bool: ...
    def get(self, arg0: int) -> bool: ...
    def none(self) -> bool: ...
    def reset(self) -> DynamicBitset: ...
    @overload
    def set(self) -> DynamicBitset: ...
    @overload
    def set(self, arg0: int, arg1: bool) -> DynamicBitset: ...
    def size(self) -> int: ...
    def __and__(self, arg0: DynamicBitset) -> DynamicBitset: ...
    def __eq__(self, arg0: DynamicBitset) -> bool: ...
    def __iand__(self, arg0: DynamicBitset) -> DynamicBitset: ...
    def __ior__(self, arg0: DynamicBitset) -> DynamicBitset: ...
    def __ne__(self, arg0: DynamicBitset) -> bool: ...
    def __or__(self, arg0: DynamicBitset) -> DynamicBitset: ...

class Expression:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: Variable) -> None: ...
    def Differentiate(self, arg0: Variable) -> Expression: ...
    @overload
    def Evaluate(self) -> float: ...
    @overload
    def Evaluate(self, arg0: dict[Variable, float]) -> float: ...
    def EvaluatePartial(self, arg0: dict[Variable, float]) -> Expression: ...
    def Expand(self) -> Expression: ...
    @overload
    def Substitute(self, arg0: Variable, arg1: Expression) -> Expression: ...
    @overload
    def Substitute(self, arg0: dict[Variable, Expression]) -> Expression: ...
    @overload
    def Substitute(self, arg0) -> Expression: ...
    @overload
    def Substitute(self, arg0: dict[Variable, Expression], arg1) -> Expression: ...
    def ToPrefix(self) -> str: ...
    def to_string(self) -> str: ...
    def __abs__(self) -> Expression: ...
    @overload
    def __add__(self, arg0: Expression) -> Expression: ...
    @overload
    def __add__(self, arg0: Variable) -> Expression: ...
    @overload
    def __add__(self, arg0: float) -> Expression: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    @overload
    def __iadd__(self, arg0: Expression) -> Expression: ...
    @overload
    def __iadd__(self, arg0: Variable) -> Expression: ...
    @overload
    def __iadd__(self, arg0: float) -> Expression: ...
    @overload
    def __imul__(self, arg0: Expression) -> Expression: ...
    @overload
    def __imul__(self, arg0: Variable) -> Expression: ...
    @overload
    def __imul__(self, arg0: float) -> Expression: ...
    @overload
    def __isub__(self, arg0: Expression) -> Expression: ...
    @overload
    def __isub__(self, arg0: Variable) -> Expression: ...
    @overload
    def __isub__(self, arg0: float) -> Expression: ...
    @overload
    def __itruediv__(self, arg0: Expression) -> Expression: ...
    @overload
    def __itruediv__(self, arg0: Variable) -> Expression: ...
    @overload
    def __itruediv__(self, arg0: float) -> Expression: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    @overload
    def __mul__(self, arg0: Expression) -> Expression: ...
    @overload
    def __mul__(self, arg0: Variable) -> Expression: ...
    @overload
    def __mul__(self, arg0: float) -> Expression: ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Expression: ...
    def __pow__(self, arg0: Expression) -> Expression: ...
    @overload
    def __radd__(self, arg0: Variable) -> Expression: ...
    @overload
    def __radd__(self, arg0: float) -> Expression: ...
    @overload
    def __rmul__(self, arg0: Variable) -> Expression: ...
    @overload
    def __rmul__(self, arg0: float) -> Expression: ...
    @overload
    def __rsub__(self, arg0: Variable) -> Expression: ...
    @overload
    def __rsub__(self, arg0: float) -> Expression: ...
    @overload
    def __rtruediv__(self, arg0: Variable) -> Expression: ...
    @overload
    def __rtruediv__(self, arg0: float) -> Expression: ...
    @overload
    def __sub__(self, arg0: Expression) -> Expression: ...
    @overload
    def __sub__(self, arg0: Variable) -> Expression: ...
    @overload
    def __sub__(self, arg0: float) -> Expression: ...
    @overload
    def __truediv__(self, arg0: Expression) -> Expression: ...
    @overload
    def __truediv__(self, arg0: Variable) -> Expression: ...
    @overload
    def __truediv__(self, arg0: float) -> Expression: ...

class Formula:
    def __init__(self, arg0: Variable) -> None: ...
    def EqualTo(self, arg0: Formula) -> bool: ...
    @overload
    def Evaluate(self) -> bool: ...
    @overload
    def Evaluate(self, arg0: dict[Variable, float]) -> bool: ...
    @staticmethod
    def FALSE() -> Formula: ...
    def GetFreeVariables(self) -> Variables: ...
    @overload
    def Substitute(self, arg0: Variable, arg1: Expression) -> Formula: ...
    @overload
    def Substitute(self, arg0: dict[Variable, Expression]) -> Formula: ...
    @staticmethod
    def TRUE() -> Formula: ...
    def ToPrefix(self) -> str: ...
    def to_string(self) -> str: ...
    @overload
    def __eq__(self, arg0: Formula) -> bool: ...
    @overload
    def __eq__(self, arg0: Variable) -> Formula: ...
    def __hash__(self) -> int: ...
    @overload
    def __ne__(self, arg0: Formula) -> bool: ...
    @overload
    def __ne__(self, arg0: Variable) -> Formula: ...
    def __nonzero__(self) -> bool: ...

class Interval:
    ALL_REALS: ClassVar[Interval] = ...  # read-only
    EMPTY_SET: ClassVar[Interval] = ...  # read-only
    HALF_PI: ClassVar[Interval] = ...  # read-only
    NEG_REALS: ClassVar[Interval] = ...  # read-only
    ONE: ClassVar[Interval] = ...  # read-only
    PI: ClassVar[Interval] = ...  # read-only
    POS_REALS: ClassVar[Interval] = ...  # read-only
    TWO_PI: ClassVar[Interval] = ...  # read-only
    ZERO: ClassVar[Interval] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    def bisect(self, arg0: float) -> tuple[Interval, Interval]: ...
    def complementary(self, arg0: Interval, arg1: Interval, arg2: bool) -> int: ...
    def contains(self, arg0: float) -> bool: ...
    def diam(self) -> float: ...
    def diff(self, arg0: Interval, arg1: Interval, arg2: Interval, arg3: bool) -> int: ...
    @overload
    def div2_inter(self, arg0: Interval, arg1: Interval, arg2: Interval) -> bool: ...
    @overload
    def div2_inter(self, arg0: Interval, arg1: Interval) -> Interval: ...
    @overload
    def inflate(self, arg0: float) -> Interval: ...
    @overload
    def inflate(self, arg0: float, arg1: float) -> Interval: ...
    def interior_contains(self, arg0: float) -> bool: ...
    def intersects(self, arg0: Interval) -> bool: ...
    def is_bisectable(self) -> bool: ...
    def is_degenerated(self) -> bool: ...
    def is_disjoint(self, arg0: Interval) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_interior_subset(self, arg0: Interval) -> bool: ...
    def is_relative_interior_subset(self, arg0: Interval) -> bool: ...
    def is_strict_interior_subset(self, arg0: Interval) -> bool: ...
    def is_strict_subset(self, arg0: Interval) -> bool: ...
    def is_strict_superset(self, arg0: Interval) -> bool: ...
    def is_subset(self, arg0: Interval) -> bool: ...
    def is_superset(self, arg0: Interval) -> bool: ...
    def is_unbounded(self) -> bool: ...
    def lb(self) -> float: ...
    def mag(self) -> float: ...
    def mid(self) -> float: ...
    def mig(self) -> float: ...
    def overlaps(self, arg0: Interval) -> bool: ...
    def rad(self) -> float: ...
    def rel_distance(self, arg0: Interval) -> float: ...
    def set_empty(self) -> None: ...
    def ub(self) -> float: ...
    def __abs__(self) -> Interval: ...
    @overload
    def __add__(self, arg0: Interval) -> Interval: ...
    @overload
    def __add__(self, arg0: float) -> Interval: ...
    def __and__(self, arg0: Interval) -> Interval: ...
    def __contains__(self, arg0: float) -> bool: ...
    def __eq__(self, arg0: Interval) -> bool: ...
    @overload
    def __iadd__(self, arg0: Interval) -> Interval: ...
    @overload
    def __iadd__(self, arg0: float) -> Interval: ...
    def __iand__(self, arg0: Interval) -> Interval: ...
    @overload
    def __imul__(self, arg0: Interval) -> Interval: ...
    @overload
    def __imul__(self, arg0: float) -> Interval: ...
    def __ior__(self, arg0: Interval) -> Interval: ...
    @overload
    def __isub__(self, arg0: Interval) -> Interval: ...
    @overload
    def __isub__(self, arg0: float) -> Interval: ...
    @overload
    def __itruediv__(self, arg0: Interval) -> Interval: ...
    @overload
    def __itruediv__(self, arg0: float) -> Interval: ...
    @overload
    def __mul__(self, arg0: Interval) -> Interval: ...
    @overload
    def __mul__(self, arg0: float) -> Interval: ...
    def __ne__(self, arg0: Interval) -> bool: ...
    def __neg__(self) -> Interval: ...
    def __or__(self, arg0: Interval) -> Interval: ...
    def __radd__(self, arg0: float) -> Interval: ...
    def __rmul__(self, arg0: float) -> Interval: ...
    def __rsub__(self, arg0: float) -> Interval: ...
    def __rtruediv__(self, arg0: float) -> Interval: ...
    @overload
    def __sub__(self, arg0: Interval) -> Interval: ...
    @overload
    def __sub__(self, arg0: float) -> Interval: ...
    @overload
    def __truediv__(self, arg0: Interval) -> Interval: ...
    @overload
    def __truediv__(self, arg0: float) -> Interval: ...

class LogLevel:
    __members__: ClassVar[dict] = ...  # read-only
    CRITICAL: ClassVar[LogLevel] = ...
    DEBUG: ClassVar[LogLevel] = ...
    ERROR: ClassVar[LogLevel] = ...
    INFO: ClassVar[LogLevel] = ...
    OFF: ClassVar[LogLevel] = ...
    TRACE: ClassVar[LogLevel] = ...
    WARNING: ClassVar[LogLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Logic:
    __members__: ClassVar[dict] = ...  # read-only
    ALL: ClassVar[Logic] = ...
    QF_LIA: ClassVar[Logic] = ...
    QF_LIRA: ClassVar[Logic] = ...
    QF_LRA: ClassVar[Logic] = ...
    QF_NIA: ClassVar[Logic] = ...
    QF_NIAT: ClassVar[Logic] = ...
    QF_NIRA: ClassVar[Logic] = ...
    QF_NIRAT: ClassVar[Logic] = ...
    QF_NRA: ClassVar[Logic] = ...
    QF_NRAT: ClassVar[Logic] = ...
    QF_RDL: ClassVar[Logic] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Variable:
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        Binary: ClassVar[Variable.Type] = ...
        Bool: ClassVar[Variable.Type] = ...
        Int: ClassVar[Variable.Type] = ...
        Real: ClassVar[Variable.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Binary: ClassVar[Variable.Type] = ...
    Bool: ClassVar[Variable.Type] = ...
    Int: ClassVar[Variable.Type] = ...
    Real: ClassVar[Variable.Type] = ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1) -> None: ...
    def get_id(self) -> int: ...
    def get_type(self, *args, **kwargs): ...
    def __abs__(self): ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other): ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rmul__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class Variables:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[Variable]) -> None: ...
    def IsStrictSubsetOf(self, arg0: Variables) -> bool: ...
    def IsStrictSupersetOf(self, arg0: Variables) -> bool: ...
    def IsSubsetOf(self, arg0: Variables) -> bool: ...
    def IsSupersetOf(self, arg0: Variables) -> bool: ...
    def empty(self) -> bool: ...
    @overload
    def erase(self, arg0: Variable) -> int: ...
    @overload
    def erase(self, arg0: Variables) -> int: ...
    def include(self, arg0: Variable) -> bool: ...
    @overload
    def insert(self, arg0: Variable) -> None: ...
    @overload
    def insert(self, arg0: Variables) -> None: ...
    def size(self) -> int: ...
    def to_string(self) -> str: ...
    @overload
    def __add__(self, arg0: Variables) -> Variables: ...
    @overload
    def __add__(self, arg0: Variable) -> Variables: ...
    def __contains__(self, arg0: Variable) -> bool: ...
    def __eq__(self, arg0: Variables) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __lt__(self, arg0: Variables) -> bool: ...
    def __radd__(self, arg0: Variable) -> Variables: ...
    @overload
    def __sub__(self, arg0: Variables) -> Variables: ...
    @overload
    def __sub__(self, arg0: Variable) -> Variables: ...

class ibex::BitSet::iterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self): ...
    def __next__(self) -> int: ...

def BuildContractor(*args, **kwargs): ...
@overload
def CheckSatisfiability(arg0: Formula, arg1: float) -> Box | None: ...
@overload
def CheckSatisfiability(arg0: Formula, arg1: Config) -> Box | None: ...
@overload
def CheckSatisfiability(arg0: Formula, arg1: float, arg2: Box) -> bool: ...
@overload
def CheckSatisfiability(arg0: Formula, arg1: Config, arg2: Box) -> bool: ...
def DeltaStrengthen(arg0: Formula, arg1: float) -> Formula: ...
def DeltaWeaken(arg0: Formula, arg1: float) -> Formula: ...
def EliminateIfThenElse(arg0: Formula) -> Formula: ...
@overload
def Max(arg0: Interval, arg1: Interval) -> Interval: ...
@overload
def Max(arg0: Expression, arg1: Expression) -> Expression: ...
@overload
def Min(arg0: Interval, arg1: Interval) -> Interval: ...
@overload
def Min(arg0: Expression, arg1: Expression) -> Expression: ...
@overload
def Minimize(arg0: Expression, arg1: Formula, arg2: float) -> Box | None: ...
@overload
def Minimize(arg0: Expression, arg1: Formula, arg2: Config) -> Box | None: ...
@overload
def Minimize(arg0: Expression, arg1: Formula, arg2: float, arg3: Box) -> bool: ...
@overload
def Minimize(arg0: Expression, arg1: Formula, arg2: Config, arg3: Box) -> bool: ...
@overload
def acos(arg0: Interval) -> Interval: ...
@overload
def acos(arg0: Expression) -> Expression: ...
def acosh(arg0: Interval) -> Interval: ...
@overload
def asin(arg0: Interval) -> Interval: ...
@overload
def asin(arg0: Expression) -> Expression: ...
def asinh(arg0: Interval) -> Interval: ...
@overload
def atan(arg0: Interval) -> Interval: ...
@overload
def atan(arg0: Expression) -> Expression: ...
@overload
def atan2(arg0: Interval, arg1: Interval) -> Interval: ...
@overload
def atan2(arg0: Expression, arg1: Expression) -> Expression: ...
def atanh(arg0: Interval) -> Interval: ...
@overload
def cos(arg0: Interval) -> Interval: ...
@overload
def cos(arg0: Expression) -> Expression: ...
@overload
def cosh(arg0: Interval) -> Interval: ...
@overload
def cosh(arg0: Expression) -> Expression: ...
def distance(arg0: Interval, arg1: Interval) -> float: ...
def div2(arg0: Interval, arg1: Interval, arg2: Interval, arg3: Interval) -> None: ...
@overload
def exp(arg0: Interval) -> Interval: ...
@overload
def exp(arg0: Expression) -> Expression: ...
def forall(*args, **kwargs): ...
@overload
def if_then_else(arg0, arg1: Expression, arg2: Expression) -> Expression: ...
@overload
def if_then_else(arg0: Variable, arg1: Expression, arg2: Expression) -> Expression: ...
def integer(arg0: Interval) -> Interval: ...
def intersect(arg0: Variables, arg1: Variables) -> Variables: ...
@overload
def log(arg0: Interval) -> Interval: ...
@overload
def log(arg0: Expression) -> Expression: ...
@overload
def logical_iff(arg0: Variable, arg1: Variable) -> Formula: ...
@overload
def logical_iff(arg0: Formula, arg1: Variable) -> Formula: ...
@overload
def logical_iff(arg0: Variable, arg1: Formula) -> Formula: ...
@overload
def logical_iff(arg0: Formula, arg1: Formula) -> Formula: ...
@overload
def logical_imply(arg0: Formula, arg1: Formula) -> Formula: ...
@overload
def logical_imply(arg0: Variable, arg1: Formula) -> Formula: ...
@overload
def logical_imply(arg0: Formula, arg1: Variable) -> Formula: ...
@overload
def logical_imply(arg0: Variable, arg1: Variable) -> Formula: ...
@overload
def logical_not(arg0: Formula) -> Formula: ...
@overload
def logical_not(arg0: Variable) -> Formula: ...
@overload
def pow(arg0: Interval, arg1: int) -> Interval: ...
@overload
def pow(arg0: Interval, arg1: float) -> Interval: ...
@overload
def pow(arg0: Interval, arg1: Interval) -> Interval: ...
@overload
def pow(arg0: Expression, arg1: Expression) -> Expression: ...
def root(arg0: Interval, arg1: int) -> Interval: ...
def set_log_level(arg0: LogLevel) -> None: ...
def sign(arg0: Interval) -> Interval: ...
@overload
def sin(arg0: Interval) -> Interval: ...
@overload
def sin(arg0: Expression) -> Expression: ...
@overload
def sinh(arg0: Interval) -> Interval: ...
@overload
def sinh(arg0: Expression) -> Expression: ...
def sqr(arg0: Interval) -> Interval: ...
@overload
def sqrt(arg0: Interval) -> Interval: ...
@overload
def sqrt(arg0: Expression) -> Expression: ...
@overload
def tan(arg0: Interval) -> Interval: ...
@overload
def tan(arg0: Expression) -> Expression: ...
@overload
def tanh(arg0: Interval) -> Interval: ...
@overload
def tanh(arg0: Expression) -> Expression: ...
