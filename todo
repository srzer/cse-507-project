Looking at the code, I believe it's safe to ignore the nd and 3d directories.
Here's why:

  Functionality Comparison:

  3d/nd versions contain:

  - Basic branch-and-bound with dReal
  - Box splitting (longest edge)
  - Feasibility checking via dReal
  - Direct minimize calls on small/fully-feasible boxes

  bernstein-nd already has everything above PLUS:

  - Bernstein bounds for cheap pruning (line 79-82 in berstein-nd/ours.py)
  - Polynomial term representation
  - Same core algorithm structure

  No functionality loss - bernstein-nd is essentially nd with enhancements.

  BoxND vs Box3D:

  Your plan to use BoxND everywhere is excellent.
  As you noted, you can just pass 3-dimensional BoxND instances where needed.
  This gives you:
  - Single box representation
  - Dimension flexibility
  - Cleaner codebase

  Integration Strategy:

  bernstein-nd + GPTBP2.py is the right focus. Key integration opportunities:

  1. Affine Arithmetic from GPTBP2 (lines 19-110) for additional cheap pruning
  2. Variable spread heuristics (lines 240-283, 285-319) for smarter box splitting instead of just longest edge
  3. Standalone Bernstein implementation as fallback when dReal unavailable

  The only thing to watch for is that bernstein-nd currently only uses Bernstein bounds for pruning but still relies heavily on dReal. GPTBP2's pure interval/Bernstein approach could reduce dReal calls further.

  Recommendation: Use bernstein-nd as your base and selectively port features from GPTBP2, especially the smart splitting heuristics which could significantly improve performance.
